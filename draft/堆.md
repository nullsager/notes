# C++ 堆的使用方法

## 1. 基本类型的堆

C++ 使用 `std::priority_queue` 实现堆，默认是**大根堆**。

```cpp
#include <queue>
#include <vector>

// 大根堆（默认）
std::priority_queue<int> maxHeap;
maxHeap.push(3);
maxHeap.push(1);
maxHeap.push(5);
// maxHeap.top() == 5

// 小根堆（使用 greater）
std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
minHeap.push(3);
minHeap.push(1);
minHeap.push(5);
// minHeap.top() == 1
```

## 2. 结构体的堆

有三种方法处理结构体：

### 方法 1: 重载 `operator<`

```cpp
struct Node {
    int value;
    int priority;
    
    // 大根堆：按 priority 降序
    bool operator<(const Node& other) const {
        return priority < other.priority; // 注意：小于号对应大根堆
    }
};

std::priority_queue<Node> maxHeap;
maxHeap.push({10, 5});
maxHeap.push({20, 3});
// top() 是 priority = 5 的元素
```

### 方法 2: 自定义比较器（仿函数）

```cpp
struct Node {
    int value;
    int priority;
};

// 小根堆比较器
struct CompareNode {
    bool operator()(const Node& a, const Node& b) const {
        return a.priority > b.priority; // 大于号对应小根堆
    }
};

std::priority_queue<Node, std::vector<Node>, CompareNode> minHeap;
```

### 方法 3: Lambda 表达式（C++11）

```cpp
struct Node {
    int value;
    int priority;
};

// 小根堆
auto cmp = [](const Node& a, const Node& b) {
    return a.priority > b.priority;
};

std::priority_queue<Node, std::vector<Node>, decltype(cmp)> minHeap(cmp);
```

## 3. 完整示例

```cpp
#include <iostream>
#include <queue>
#include <vector>

struct Task {
    std::string name;
    int priority;
};

int main() {
    // 大根堆：优先级高的先出
    auto cmp = [](const Task& a, const Task& b) {
        return a.priority < b.priority;
    };
    
    std::priority_queue<Task, std::vector<Task>, decltype(cmp)> taskQueue(cmp);
    
    taskQueue.push({"Task A", 3});
    taskQueue.push({"Task B", 1});
    taskQueue.push({"Task C", 5});
    
    while (!taskQueue.empty()) {
        auto task = taskQueue.top();
        taskQueue.pop();
        std::cout << task.name << " (priority: " << task.priority << ")\n";
    }
    // 输出顺序: Task C(5) -> Task A(3) -> Task B(1)
    
    return 0;
}
```

## 4. 记忆技巧

- **比较符号与堆类型相反**：
  - `<` 对应**大根堆**
  - `>` 对应**小根堆**
  
- 原因：`priority_queue` 内部维护的是"最大堆"，比较器返回 `true` 时表示第一个元素"更小"，应该往下沉

## 5. 常用操作

```cpp
pq.push(x);      // 插入元素
pq.top();        // 访问堆顶（不删除）
pq.pop();        // 删除堆顶
pq.empty();      // 判空
pq.size();       // 元素个数
```

小根堆需要维护 `operator >`
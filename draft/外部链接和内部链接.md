函数默认具有外部链接，但可以通过 static 关键字设置为内部链接：

util.cpp:

```cpp
int add(int x, int y) {
	return x + y;
}
```

main.cpp:

```cpp
#include <iostream>
int add(int x, int y);
int main() {
    std::cout << add(3, 4) << '\n';
    return 0;
}
```

这段代码是可以成功编译的，但如果把util.cpp修改为：

```cpp
static int add(int x, int y) {
    return x + y;
}
```

则会发生链接失败，因为函数add在add.cpp之外不可访问。

---

非const变量默认具有外部链接，但const变量是内部链接的。

例如，util.cpp如下：

```cpp
int g_x = 10;
```

main.cpp:

```cpp
#include <iostream>
extern int g_x;
int main() {
    std::cout << g_x << '\n';
}
```

这两段代码中util.cpp不需要使用extern来赋予g_x外部链接即可正常编译，但假如g_x是const型变量，即`const int g_x = 10`，那么会发生链接错误，必须将其修改为`extern int g_x = 10`才能链接成功

---

在头文件中定义常量，推荐使用inline来定义，例如，使用：

```cpp
namespace constants {
    // Global constants have internal linkage by default
    constexpr double pi { 3.14159 };
    constexpr double avogadro { 6.0221413e23 };
}
```

这种情况下头文件 被 include 到不同的代码文件中时，这些变量都会被复制到包含的代码文件中。因此，如果 头文件被包含到 20 个不同的代码文件中，这些变量就会被重复 20 次。头文件保护并不能阻止这种情况发生，因为它们只防止一个头文件在单个包含文件中被包含多次，而不是在多个不同的代码文件中被包含一次。

这会使每个包含头文件的翻译单元都有自己的变量副本，浪费一定的内存。

因此，可以将上面的代码优化为：

```cpp
namespace constants {
    inline constexpr double pi { 3.14159 }; // note: now inline constexpr
    inline constexpr double avogadro { 6.0221413e23 };
}
```

这些变量只会被实例化一次，并在所有代码文件中共享，每个变量只需要一份副本。

其实这个原理比较简单，constexpr变量默认为内部链接，头文件如果包含在不同源文件中，会被解释为不同的内容，可以正常编译（如果是非const变量包含在头文件中，被不同的源文件所引用，那么直接会发生链接失败，因为非const变量默认具有外部链接），但如果使用inline进行去重，那么只会保留剩下一份定义。


> [!info] 注意
> constexpr 函数是隐式内联的，但 constexpr 变量不是隐式内联的。如果你想要一个内联 constexpr 变量，必须明确将其标记为 inline

---

无名命名空间的效果是，所有在无名命名空间内的标识符都被视为具有内部链接，这意味着无名命名空间的内容无法在定义无名命名空间的文件之外被看到。这种方式可以用在替换掉大量的使用static函数/static变量的情况下。

内联命名空间通常用于版本控制内容。与未命名命名空间类似，内联命名空间内声明的任何内容都被视为父命名空间的一部分。然而，与未命名命名空间不同，内联命名空间不会影响链接。

```cpp
#include <iostream>
inline namespace V1 {
    void doSomething() { std::cout << "V1\n"; }
}
namespace V2 {
    void doSomething() { std::cout << "V2\n"; }
}
int main() {
    V1::doSomething(); // calls the V1 version of doSomething()
    V2::doSomething(); // calls the V2 version of doSomething()
    doSomething(); // calls the inline version of doSomething() (which is V1)
}
```
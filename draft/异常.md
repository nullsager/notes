`std::exception` 定义在 `<exception>` 头文件中，是所有 C++标准库异常的父类。它有一个重要的虚函数 `what()`，该函数返回一个 `const char*`，用于描述异常的具体信息。

标准库中的异常主要定义在 `<stdexcept>` 头文件中，它们可以分为两大类：**逻辑错误（Logic Errors）** 和 **运行时错误（Runtime Errors）**。

### 1\. 逻辑错误 (Logic Errors) - `std::logic_error`

逻辑错误通常是可以（并且应该）在程序编码阶段就被预见和避免的。它们通常源于代码的内部逻辑问题，比如违反了函数的前提条件。`std::logic_error` 是所有逻辑错误的基类。

以下是 `std::logic_error` 的一些常见子类：

| 异常类型 | 描述 | 常见触发场景 |
| :--- | :--- | :--- |
| **`std::invalid_argument`** | **无效参数** | 当传递给函数的参数值不合法或不适当。例如，一个数学函数接收到了一个定义域之外的值。 |
| **`std::domain_error`** | **定义域错误** | 主要用于数学计算中，当一个参数在数学上没有意义时抛出。例如，对一个负数取平方根。 |
| **`std::length_error`** | **长度错误** | 当尝试创建一个超出其最大允许长度的对象时。例如，`std::vector` 或 `std::string` 分配了过大的尺寸。 |
| **`std::out_of_range`** | **越界错误** | 当试图访问一个序列容器（如 `std::vector`, `std::string`）中不存在的元素时。例如，使用 `.at()` 方法访问一个超出索引范围的元素。 |
| **`std::future_error`** | **未来错误** (C++11) | 与异步操作（`std::future`, `std::promise`）相关，当违反了其使用前提条件时抛出。 |

**示例 (std:: out\_of\_range):**

```cpp
#include <iostream>
#include <vector>
#include <stdexcept>

int main() {
    std::vector<int> my_vector = {10, 20, 30};
    try {
        int value = my_vector.at(5); // .at()会进行边界检查
        std::cout << value << std::endl;
    } catch (const std::out_of_range& e) {
        std::cerr << "捕获到异常: " << e.what() << std::endl;
        std::cerr << "错误: 尝试访问越界索引！" << std::endl;
    }
    return 0;
}
```

**输出:**

```
捕获到异常: vector::_M_range_check: __n (which is 5) >= this->size() (which is 3)
错误: 尝试访问越界索引！
```

### 2\. 运行时错误 (Runtime Errors) - `std::runtime_error`

运行时错误通常是由外部因素或程序执行期间发生的、难以预测和预防的事件引起的。`std::runtime_error` 是所有运行时错误的基类。

以下是 `std::runtime_error` 的一些常见子类：

| 异常类型 | 描述 | 常见触发场景 |
| :--- | :--- | :--- |
| **`std::range_error`** | **范围错误** | 当计算结果无法用目标类型表示时。例如，一个计算结果超出了该类型所能表示的最大值或最小值。 |
| **`std::overflow_error`** | **上溢错误** | 当算术运算的结果超出了目标类型的最大可表示值。 |
| **`std::underflow_error`** | **下溢错误** | 当算术运算的结果太小，无法在目标类型中表示（接近于零）。 |
| **`std::system_error`** | **系统错误** (C++11) | 描述底层的操作系统错误。它通常包含一个错误码，可以映射到具体的系统错误信息。 |

**示例 (std:: runtime\_error):**

```cpp
#include <iostream>
#include <stdexcept>
#include <fstream>

void read_file(const std::string& filename) {
    std::ifstream file(filename);
    if (!file) {
        throw std::runtime_error("无法打开文件: " + filename);
    }
    // ... 文件处理逻辑 ...
    std::cout << "文件打开成功！" << std::endl;
}

int main() {
    try {
        read_file("non_existent_file.txt");
    } catch (const std::runtime_error& e) {
        std::cerr << "捕获到运行时错误: " << e.what() << std::endl;
    }
    return 0;
}
```

**输出:**

```
捕获到运行时错误: 无法打开文件: non_existent_file.txt
```

### 3\. 其他标准异常

除了上述两大类，C++ 标准库中还有一些其他重要的异常类型：

| 异常类型 | 头文件 | 描述 | 常见触发场景 |
| :--- | :--- | :--- | :--- |
| **`std::bad_alloc`** | `<new>` | **内存分配失败** | 当 `new` 操作符无法成功分配所需的内存时抛出。这通常意味着堆内存耗尽。 |
| **`std::bad_cast`** | `<typeinfo>` | **非法类型转换** | 当使用 `dynamic_cast` 对引用进行向下转型且转换失败时抛出。 |
| **`std::bad_typeid`** | `<typeinfo>` | **非法类型 ID** | 当对一个空指针使用 `typeid` 操作符时抛出。 |
| **`std::bad_exception`** | `<exception>` | **坏异常** | 这是一个特殊的异常，当一个函数抛出了其 `throw()` 异常规范中未列出的异常时，`unexpected()` 函数可能会抛出 `std::bad_exception`。 (在 C++11 中，异常规范已弃用，在 C++17 中被移除) |

**示例 (std:: bad\_alloc):**

```cpp
#include <iostream>
#include <new> // 需要包含<new>头文件
#include <vector>

int main() {
    try {
        // 尝试分配一个非常巨大的数组，很可能会失败
        long long size = -1; // 使用一个非常大的正数或者一个不合理的值
        int* huge_array = new int[size];
        delete[] huge_array;
    } catch (const std::bad_alloc& e) {
        std::cerr << "捕获到异常: " << e.what() << std::endl;
        std::cerr << "错误: 内存分配失败！" << std::endl;
    }
    return 0;
}
```

**输出:**

```
捕获到异常: std::bad_alloc
错误: 内存分配失败！
```

### 异常继承体系图

为了更好地理解它们的关系，可以参考下面的继承体系：

```
std::exception
├── std::logic_error
│   ├── std::invalid_argument
│   ├── std::domain_error
│   ├── std::length_error
│   └── std::out_of_range
├── std::runtime_error
│   ├── std::range_error
│   ├── std::overflow_error
│   └── std::underflow_error
├── std::bad_alloc
├── std::bad_cast
├── std::bad_typeid
└── ... 其他
```

### 总结与最佳实践

1.  **优先使用标准异常**：当需要抛出异常时，首先考虑使用标准库中已定义的、语义相符的异常类型。这使得代码更易于被其他开发者理解。
2.  **按引用捕获**：始终通过 `const` 引用（`catch (const std::exception& e)`）来捕获异常。这可以避免不必要的对象拷贝，并且可以防止对象切割（slicing），确保多态性得以保留。
3.  **捕获顺序**：如果需要捕获多种异常，应该将子类异常的 `catch` 块放在基类异常的前面，否则子类异常将永远不会被捕获。
4.  **自定义异常**：对于特定于应用程序的错误，可以创建自定义异常类。最佳实践是让自定义异常类继承自 `std::exception` 或其某个子类（如 `std::runtime_error`），并重写 `what()` 方法。

好的，我们来详细讲解一下这段代码背后所阐述的 C++ 核心准则：**析构函数绝不能抛出异常**。

这是一个在 C++ 中非常重要的健壮性编程原则。如果违反，可能会导致程序立即崩溃或资源泄漏。

---

### 为什么析构函数抛出异常是“坏”的？

要理解这个问题，我们首先要明白 C++ 的异常处理机制是如何工作的，特别是“**栈回溯**”（Stack Unwinding）的过程。

1.  当一个异常被 `throw` 抛出时，程序会暂停当前函数的执行。
2.  它会开始沿着函数调用栈向后“回溯”，寻找一个能够处理该异常的 `catch` 块。
3.  在回溯的过程中，**C++ 运行时会负责销毁（调用析构函数）所有在 `try` 块之后、`throw` 语句之前创建的局部对象（自动变量）**。这个过程就是“栈回溯”，它的目的是确保即使在异常发生时，资源也能被正确释放。

**现在，关键问题来了：**

如果在“栈回溯”的过程中，为了销毁一个对象而调用的析构函数**本身又抛出了一个新的异常**，会发生什么？

这时，系统就面临一个两难的境地：第一个异常还没有被处理，现在又来了一个新的异常。C++ 标准规定，在这种情况下，程序无法安全地继续执行，因此会立即调用 `std::terminate()` 函数，导致**程序强制终止**。

#### 代码示例分析

让我们看看你的第一个例子：

```cpp
class E {
public:
  ~E () { 
    // throw some_exception;  // 假设这里抛出异常 ⇒ 极其危险!
  }
};

class A {
  // ... 其他成员
  E e;
  D d;
  // ...
};

void func() {
    A my_a;
    // ... 做一些操作，可能会抛出异常
    throw std::runtime_error("Something went wrong!"); 
    // ^^^ 1. 第一个异常被抛出
} // func() 结束，my_a 需要被销毁
```

在这个场景中：

  * `func()` 抛出了一个 `runtime_error` 异常。
  * 异常处理机制开始进行“栈回溯”，需要销毁局部对象 `my_a`。
  * 销毁 `my_a` 会导致其成员的析构函数被调用（顺序与声明相反）。假设轮到销毁成员 `e`。
  * 此时调用 `E` 的析构函数 `~E()`，而 `~E()` **自己又抛出了一个异常**。
  * **结果**：第一个异常（`runtime_error`）还没处理完，第二个异常又从析构函数里冒了出来。程序立即调用 `std::terminate()` 崩溃。

-----

### 正确的做法：在析构函数内部处理所有异常

那么，如果析构函数中调用的代码（比如关闭文件、断开网络连接等）确实有可能失败并抛出异常，我们该怎么办？

答案是：**必须在析构函数内部捕获并处理掉所有可能抛出的异常，绝不能让任何异常“逃逸”出析构函数的范围。**

这正是你的第二个代码片段所展示的解决方案：

```cpp
class MyType {
public:
  ~MyType () { // 析构函数默认是 noexcept(true) 的
    try {
      // 在这里执行可能会抛出异常的清理代码，
      // 比如关闭一个网络连接、释放一个复杂资源等。
      potentially_throwing_cleanup_code();

    } catch (const std::exception& e) {
      // 捕获特定类型的异常
      // 1. 记录日志
      // 2. 调用一个不会失败的备用清理函数
      // 3. 或者干脆“吞掉”这个异常，因为在析构阶段，
      //    保证程序不崩溃比报告一个清理失败更重要。
      std::cerr << "Exception caught during destruction: " << e.what() << std::endl;

    } catch (...) {
      // 捕获所有其他类型的异常
      // 同样，处理它，但不要让它传播出去。
      std::cerr << "Unknown exception caught during destruction." << std::endl;
    }
  }
  // ...
};
```

#### 核心思想总结

1.  **首要原则**：尽量让析构函数足够简单，不执行任何可能失败的操作。
2.  **次要原则**：如果无法避免在析构函数中执行可能抛出异常的代码，那么必须用 `try...catch` 块将其完全包裹。
3.  **处理方式**：在 `catch` 块中，你可以记录错误日志、尝试进行一些补偿操作，但**绝对不能**将异常再次抛出或让它逃离析构函数。通常最好的做法是“吞掉”异常，以保证程序的稳定性。

**记住**：析构函数的首要任务是安全、可靠地释放资源。让一个异常从析构函数中跑出来，是对这个核心任务的严重破坏。在现代 C++ (C++11 及以后) 中，析构函数默认被标记为 `noexcept`，如果你试图在其中抛出异常而没有处理，编译器可能会警告，并且程序在运行时同样会调用 `std::terminate()`。
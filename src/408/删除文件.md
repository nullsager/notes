分析两个主要场景：

## 场景1：删除关闭的文件且没有其他硬链接

这是最简单的情况。用户运行rm myfile.txt。文件没有被任何进程打开，也没有其他名称。

**文件目录（在磁盘上）**：
变化：被修改。myfile.txt的目录项（dentry）（包含文件名和相应的inode号）从父目录的数据块中移除。文件名不再存在。

**inode（在磁盘上）**：
变化：被修改然后被释放。
首先，其链接计数器从1递减到0。
因为链接计数器现在为0（打开计数器也为0），内核立即释放资源。
inode指向的数据块在文件系统的空闲位图中被标记为空闲。
inode本身在inode位图中被标记为空闲。

**vnode（在内存中）**：
变化：失效并被移除。如果该文件的碰巧在内核缓存中（最近访问过），它现在被失效并将从缓存中移除，因为其磁盘上的底层inode已被释放。如果它不在缓存中，则没有变化。

**系统打开文件表（在内存中）**：
变化：无变化。因为文件未被打开，所以该表中根本没有它的条目。

**文件描述符表（在内存中）**：
变化：无变化。因为没有进程打开该文件，所以没有进程有指向它的文件描述符。

## 场景2：删除当前被进程打开的文件

这是一个非常常见且重要的场景。一个进程正在向logfile.txt写入，用户在shell中运行rm logfile.txt。

**文件目录（在磁盘上）**：
变化：被修改。logfile.txt的目录项被移除。从文件系统目录结构的角度来看，文件已经消失。你无法用ls看到它，没有新进程可以按名称通过open()打开它。

**inode（在磁盘上）**：
变化：链接计数器被修改，但inode尚未释放。
inode的链接计数器从1递减到0。
内核检查是否可以释放inode。它看到链接计数器为0，但它也检查内存中vnode的打开计数器并发现它大于0。
因此，inode及其所有关联的数据块在磁盘上以"待删除"状态保存。

**vnode（在内存中）**：
变化：保持活跃。该文件的vnode绝对存在于内存中（因为文件是打开的）。其打开计数器非零。rm操作导致缓存inode数据中的链接计数器设置为0，但vnode本身保持完全运行状态。

**系统打开文件表（在内存中）**：
变化：无变化。运行进程使用的条目仍然完全有效。它仍然跟踪文件的当前读/写偏移量，仍然指向相同的vnode。进程可以继续读写文件而不会出现任何错误。

**文件描述符表（在内存中）**：
变化：无变化。进程的文件描述符（例如fd=3）仍然指向系统打开文件表中的完全相同的条目。

## 场景2中后续会发生什么？

当最终打开该文件的进程调用其文件描述符上的close()（或进程终止）时，会发生以下情况：

- vnode的打开计数器递减。
- 内核现在看到打开计数器已变为0。
- 它重新检查磁盘上的链接计数器（也为0）。
- 既然现在满足两个条件（link_count == 0和open_count == 0），内核最终从磁盘中释放inode及其数据块。

### 总结表

| 数据结构      | 场景1：删除关闭的文件         | 场景2：删除打开的文件                |
| --------- | ------------------- | -------------------------- |
| 文件目录（磁盘）  | 条目被移除               | 条目被移除                      |
| inode（磁盘） | 链接计数器→0。Inode和数据被释放 | 链接计数器→0。Inode和数据不被释放（直到关闭） |
| vnode（内存） | 失效/从缓存中移除           | 保持活跃和使用中                   |
| 系统打开文件表   | 无变化（从未存在）           | 无变化（进程继续使用）                |
| 文件描述符表    | 无变化（从未存在）           | 无变化（进程继续使用）                |

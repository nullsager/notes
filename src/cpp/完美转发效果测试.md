```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <utility>

class MyType {
public:
  MyType() { std::cout << "MyType 默认构造\n"; }
  MyType(const MyType&) { std::cout << "MyType 拷贝构造\n"; }
  MyType(MyType&&) { std::cout << "MyType 移动构造\n"; }
  int data = 42; // 添加数据成员，避免空类优化
};

// 左值版本：输出到 ostream，同时打印到控制台
std::ostream& operator<<(std::ostream& os, const MyType&) {
  std::cout << "[operator<< 左值版本被调用]\n"; // 直接输出到控制台
  os << "Left";
  return os;
}

// 右值版本：优化版
std::ostream& operator<<(std::ostream& os, MyType&&) {
  std::cout << "[operator<< 右值版本被调用]\n"; // 直接输出到控制台
  os << "Right";
  return os;
}

template <typename T>
std::string to_string_forward(T&& arg) {
  std::ostringstream oss;
  oss << std::forward<T>(arg);  // 关键对比点
  return oss.str();
}

template <typename T>
std::string to_string_no_forward(T&& arg) {
  std::ostringstream oss;
  oss << arg;  // 直接传递
  return oss.str();
}

int main() {
  system("chcp 65001");
  MyType obj;

  std::cout << "\n=== 测试 to_string_forward ===\n";
  std::cout << "结果1（左值）: " << to_string_forward(obj) << "\n";
  std::cout << "结果2（右值）: " << to_string_forward(MyType{}) << "\n";

  std::cout << "\n=== 测试 to_string_no_forward ===\n";
  std::cout << "结果3（左值）: " << to_string_no_forward(obj) << "\n";
  std::cout << "结果4（右值）: " << to_string_no_forward(MyType{}) << "\n";

  return 0;
}
```

输出结果：

```
MyType 默认构造

=== 测试 to_string_forward ===
结果1（左值）: [operator<< 左值版本被调用]
Left
结果2（右值）: MyType 默认构造
[operator<< 右值版本被调用]
Right

=== 测试 to_string_no_forward ===
结果3（左值）: [operator<< 左值版本被调用]
Left
结果4（右值）: MyType 默认构造
[operator<< 左值版本被调用]
Left
```
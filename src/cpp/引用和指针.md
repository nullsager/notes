---
id: 引用和指针
aliases: []
tags: []
---

左值引用只能绑定到可修改的左值：

```cpp
const int x { 5 };
int& ref { x }; // 会发生报错
```

但对 const 的左值引用可以绑定到可修改的左值：

```cpp
int x { 5 };
const int& ref { x };  // 合法
```

指向 const 的 lvalue 引用可以绑定到 rvalue：

```cpp
const int& ref { 5 }; // 使用const是合法的，但改为int& ref{5}会报错
std::cout << ref << '\n';
```

当这种情况发生时，会创建一个临时对象并用 rvalue 初始化，并且对 const 的引用绑定到该临时对象。

---

对 const 的左值引用可以绑定到不同类型的值，只要这些值可以隐式转换为引用类型：

```cpp
const double& r1 { 5 };
std::cout << r1 << '\n'; // prints 5

char c { 'a' };
const int& r2 { c };
std::cout << r2 << '\n'; // prints 97
```

> [!warning] 注意
> 这里一定得是const引用类型才能进行隐式类型转换，非const引用会发生报错

> [!tip] tips
> 如果您尝试将一个 const 左值引用绑定到不同类型的值，编译器将创建一个与引用相同类型的临时对象，使用该值进行初始化，然后将引用绑定到临时对象。

```cpp
int x = 1;
const int64_t& y = x;
x++;
std::cout << y << '\n';  // 由于绑定的是一个临时对象，这里y输出的值仍然为1
```

一般来说，临时对象通常在创建它们的表达式结束时被销毁，那么按道理来说，在类似`const int& r1 { 5 };`这样的语句结束之后，产生的临时对象会被销毁，那么这难道不会引起引用悬空吗？

其实并不会，C++ 有一个特殊规则：**当一个 const lvalue 引用直接绑定到一个临时对象时，临时对象的生命周期会延长以匹配引用的生命周期**。

> [!tip] tips
> 生命周期延长仅在 const 引用直接绑定到临时对象时有效。从函数返回的临时对象（即使是通过 const 引用返回的）不符合生命周期延长的条件。

```cpp
const int& returnByConstReference(const int& ref) {
    return ref;
}
int main() {
    // case 1: direct binding
    const int& ref1 { 5 }; // extends lifetime
    std::cout << ref1 << '\n'; // okay

    // case 2: indirect binding
    const int& ref2 { returnByConstReference(5) }; // binds to dangling reference
    std::cout << ref2 << '\n'; // undefined behavior
}
```

这里ref2是未定义行为是因为5产生的临时变量并不是直接绑定在ref2上，而是绑定在了ref上，但ref在退出函数定义域之后被销毁了。

只有在对临时对象的直接绑定时，生命周期扩展才适用。

---

constexpr引用有一个特定的限制：它们只能绑定到具有静态持续时间的对象（无论是全局变量还是静态局部变量）:

```cpp
int g_x { 5 };
int main() {
    constexpr int& ref1 { g_x }; // ok, can bind to global
    static int s_x { 6 };
    constexpr int& ref2 { s_x }; // ok, can bind to static local
    int x { 6 };
    constexpr int& ref3 { x }; // compile error: can't bind to non-static object
}
```

如果使用`static const`型的静态变量，那么constexpr引用也应该修改为`constexpr const`：

```cpp
static const int s_x { 6 };
constexpr const int& ref2 { s_x };  // 这里把const去掉会报错
```

---

const与指针

不能将普通指针指向常量变量：

```cpp
const int x { 5 };
int* ptr { &x };  // 编译错误
```

Pointer to const value  指向常量值的指针（低级别的常量）：

```cpp
const int x{ 5 };
const int* ptr { &x }; // okay: ptr is pointing to a "const int"
*ptr = 6; // not allowed: we can't change a const value
ptr = &y; // okay: ptr now points at const int y
```

Const pointers  常量指针（顶级常量）：

```cpp
int x{ 5 };
int y{ 6 };
int* const ptr { &x }; // okay: the const pointer is initialized to the address of x
ptr = &y; // error: once initialized, a const pointer can not be changed.
*ptr = 6; // okay: the value being pointed to is non-const
```

> [!info] 注意
> 类型推导只丢弃顶层 const。低层 const 不会被丢弃

```cpp
#include <string>
const std::string& getConstRef(); // some function that returns a const reference
int main() {
    auto ref1{ getConstRef() };        // std::string (reference and top-level const dropped)
    const auto ref2{ getConstRef() };  // const std::string (reference dropped, const dropped, const reapplied)
    auto& ref3{ getConstRef() };       // const std::string& (reference dropped and reapplied, low-level const not dropped)
    const auto& ref4{ getConstRef() }; // const std::string& (reference dropped and reapplied, low-level const not dropped)
}
```

在ref1中，我们会先丢弃掉&，这时类型为const std::string，此时的const为顶层的const，会被丢弃。

在ref3中，由于使用了auto&，导致类型仍然为const std::string&，此时const为底层const，不会被丢弃。

```cpp
#include <string_view>
#include <iostream>
constexpr std::string_view hello { "Hello" };   // implicitly const
constexpr const std::string_view& getConstRef() // function is constexpr, returns a const std::string_view&
{
    return hello;
}
int main() {
    auto ref1{ getConstRef() };                  // std::string_view (reference dropped and top-level const dropped)
    constexpr auto ref2{ getConstRef() };        // constexpr const std::string_view (reference dropped and top-level const dropped, constexpr applied, implicitly const)
    auto& ref3{ getConstRef() };                 // const std::string_view& (reference reapplied, low-level const not dropped)
    constexpr const auto& ref4{ getConstRef() }; // constexpr const std::string_view& (reference reapplied, low-level const not dropped, constexpr applied)
}
```

---

指针的引用：

```cpp
#include <iostream>
void nullify(int*& refptr) {  // 写成int&*会报错
    refptr = nullptr; // Make the function parameter a null pointer
}
int main() {
    int x{ 5 };
    int* ptr{ &x }; // ptr points to x
    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");
    nullify(ptr);
    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");
}
```

输出结果：

```
ptr is non-null
ptr is null
```

---

使用std::nullptr_t来编写一个只接受 nullptr 字面量参数的函数：

```cpp
#include <iostream>
#include <cstddef> // for std::nullptr_t
void print(std::nullptr_t) {
    std::cout << "in print(std::nullptr_t)\n";
}
void print(int*) {
    std::cout << "in print(int*)\n";
}
int main() {
    print(nullptr); // calls print(std::nullptr_t)
    int x { 5 };
    int* ptr { &x };
    print(ptr); // calls print(int*)
    ptr = nullptr;
    print(ptr); // calls print(int*) (since ptr has type int*)
}
```

---

如果一个函数返回一个引用，并且该引用用于初始化或赋值给一个非引用变量，则返回值将被复制（就像它是按值返回的一样）：

```cpp
const int& getNextId() {
    static int s_x{ 0 };
    ++s_x;
    return s_x;
}
int main() {
    const int id1 { getNextId() }; // id1 is a normal variable now and receives a copy of the value returned by reference from getNextId()
    const int id2 { getNextId() }; // id2 is a normal variable now and receives a copy of the value returned by reference from getNextId()
    std::cout << id1 << id2 << '\n';  // 输出结果为12
}
```

---

类型推导和常量指针：

```cpp
#include <string>
std::string* getPtr(); // some function that returns a pointer

int main() {
    const auto ptr1{ getPtr() };  // std::string* const
    auto const ptr2 { getPtr() }; // std::string* const
    const auto* ptr3{ getPtr() }; // const std::string*
    auto* const ptr4{ getPtr() }; // std::string* const
}
```

使用 auto const 或 const auto 时，意思是将推导出的指针变为**常量指针**。

当我们使用 auto* 时，const 限定符的顺序很重要。左侧的 const 意味着“将推导出的指针变为指向 const 的指针”，而右侧的 const 意味着“将推导出的指针类型变为 const 指针”。


源代码：

```c
void strcpy(char x[], char y[]) {
	size_t i;
	i = 0;
	while ((x[i] = y[i]) != '\0') {
		i += 1;
	}
}
```

汇编代码：

```
strcpy:
        addi    sp,sp,-48
        sw      ra,44(sp)
        sw      s0,40(sp)
        addi    s0,sp,48
        sw      a0,-36(s0)
        sw      a1,-40(s0)
        sw      zero,-20(s0)
        j       .L2
.L3:
        lw      a5,-20(s0)
        addi    a5,a5,1
        sw      a5,-20(s0)
.L2:
        lw      a4,-40(s0)
        lw      a5,-20(s0)
        add     a4,a4,a5
        lw      a3,-36(s0)
        lw      a5,-20(s0)
        add     a5,a3,a5
        lbu     a4,0(a4)
        sb      a4,0(a5)
        lbu     a5,0(a5)
        bne     a5,zero,.L3
        nop
        nop
        lw      ra,44(sp)
        lw      s0,40(sp)
        addi    sp,sp,48
        jr      ra
```

相关寄存器：
+ a0, a1：形参 x、y。
+ s0：帧指针（frame pointer）。
+ ra：返回地址。
+ a4/a5：编译器当作临时寄存器用。

函数序言（建立栈帧）：
+ addi sp, sp, -48：栈上分配 48 字节。
+ sw ra, 44(sp)；sw s0, 40(sp)：保存返回地址和旧的帧指针。
+ addi s0, sp, 48：设置帧指针 s0 指向“栈顶”（便于用固定偏移访问局部变量和形参拷贝）。
+ sw a0, -36(s0)；sw a1, -40(s0)：把形参 x、y 存到栈上的槽位。
+ sw zero, -20(s0)：i = 0。

栈帧里各槽位（相对于 s0）的含义:

+ -40(s0)：保存的 y 指针
+ -36(s0)：保存的 x 指针
+ -20(s0)：局部变量 i
+ 40(sp)、44(sp)：分别保存的 s0 和 ra（在函数尾恢复）

循环主体与条件

.L2 是“检查/拷贝”位置，.L3 是“i++”位置（等价于 for 循环的“增量”块）。

在 .L2：
+ lw a4, -40(s0)；lw a5, -20(s0)；add a4, a4, a5：计算 y+i 的地址到 a4。
lw a3, -36(s0)；lw a5, -20(s0)；add a5, a3, a5：计算 x+i 的地址到 a5。
lbu a4, 0(a4)：读取 y[i] 的字节到 a4。
sb a4, 0(a5)：把字节写到 x[i]。
lbu a5, 0(a5)：把刚写入的字节再读回到 a5（用于判断是否为 0）。
bne a5, zero, .L3：如果不是 '\0'，跳到 .L3 做 i++ 并继续循环；否则（等于 0）结束循环。
.L3（增量块）：
lw a5, -20(s0)；addi a5, a5, 1；sw a5, -20(s0)：i = i + 1
j .L2：回到循环头，进行下一次复制。
函数尾（恢复现场并返回）

恢复 ra、s0；还原 sp；jr ra 返回。因为你的 C 函数声明为 void strcpy(...)，所以没有设置返回值。如果声明为标准库形式 char* strcpy(...)，通常会在返回前把 a0 设为 x（例如在序言里把 a0 存栈，尾声前再读回到 a0）。
一些细节与小结

使用 lbu（无符号字节加载）+ sb 逐字节复制，确保比较 '\0' 时是按无符号零扩展处理。检查的是目的地址里的字节（刚写进去的），效果与直接检查源 y[i] 相同。
这是未优化（类似 -O0）的代码风格：把参数和局部变量放在栈上，每次循环都从栈取 i、x、y，地址重复计算，而且写完又读回再比较。优化后通常会把 i 保存在寄存器里，甚至根本不用 i，而是用指针自增，并直接用已加载的那个寄存器做比较，减少内存访问。例如优化版的思路：
t = lbu (a1); sb t, (a0); a1++; a0++; if (t != 0) 跳回
末尾的 nop 指令没有语义效果，通常是填充/对齐。
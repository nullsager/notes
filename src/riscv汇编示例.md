源代码：

```c
int fact(int n) {
    if (n < 1) return 1;
    else return n * fact(n - 1);
}
```

riscv-64汇编代码：

```asm
fact:
        addi    sp,sp,-32
        sd      ra,24(sp)
        sd      s0,16(sp)
        addi    s0,sp,32
        mv      a5,a0
        sw      a5,-20(s0)
        lw      a5,-20(s0)
        sext.w  a5,a5
        bgt     a5,zero,.L2
        li      a5,1
        j       .L3
.L2:
        lw      a5,-20(s0)
        addiw   a5,a5,-1
        sext.w  a5,a5
        mv      a0,a5
        call    fact
        mv      a5,a0
        lw      a4,-20(s0)
        mulw    a5,a4,a5
        sext.w  a5,a5
.L3:
        mv      a0,a5
        ld      ra,24(sp)
        ld      s0,16(sp)
        addi    sp,sp,32
        jr      ra
```

栈帧结构：

```
高地址
s0 (= sp + 32) ──> 这是“帧顶”（刚好在本帧之上，用作帧指针）
[sp+24 .. sp+31] 保存的 ra（返回地址）
[sp+16 .. sp+23] 保存的 s0（调用者的帧指针）
[sp+12 .. sp+15] 局部变量 int n（从 a0 拷贝来的参数）
[sp+00 .. sp+11] 未用/对齐（可能被编译器当作临时溢出区）
低地址
```

同一信息用 s0 偏移表示：

```
n 在 [s0-20 .. s0-17]
保存的 s0 在 [s0-16 .. s0-9]（等同 sp+16）
保存的 ra 在 [s0-8 .. s0-1]（等同 sp+24）
```

x0=zero(常量0), x1=ra(返回地址), x2=sp(栈指针), x8=s0/fp(帧指针), x10=a0(第1参数/返回值), x14=a4, x15=a5。

函数入口/栈帧建立（prologue）
- fact:
  函数标签。
- addi sp, sp, -32
  在栈上分配 32 字节作为当前函数的栈帧空间，sp 向下移动。
- sd ra, 24(sp)
  把返回地址寄存器 ra 保存到当前栈帧 sp+24 处。因为本函数要调用子函数（递归），必须先保存 ra。
- sd s0, 16(sp)
  把**旧的帧指针 s0** 保存到栈上 sp+16 处（这里s0不是sp+32）。s0 是被调用者需要保存的寄存器。
- addi s0, sp, 32
  设置新的帧指针 s0=sp+32（也就是指向进入本函数前的旧 sp）。后续用 s0 作基址访问局部变量。

参数保存到局部变量
- mv a5, a0
  把参数 n（在 a0）拷贝到 a5 临时寄存器。
  注：mv 是伪指令，等价 addi a5,a0,0。
- sw a5, -20(s0)
  把 a5 的低 32 位（n，int）存到局部变量槽位 s0-20 处。这里用 4 字节对齐的 int 槽位。
  说明：s0 此时是“帧顶”，局部变量放在 s0 的负偏移。
- lw a5, -20(s0)
  从局部变量槽重新取回 n 到 a5（32 位装载，RV64 下 lw 会做有符号扩展）。
- sext.w a5, a5
  把 a5 按 32 位有符号数扩展到 64 位，确保后续 64 位比较/运算的高位一致。
  注：sext.w 是伪指令，等价 addiw a5,a5,0。

分支：基例还是递归
- bgt a5, zero, .L2
  如果 n > 0 跳到 .L2（递归分支）。否则执行基例。
  注：bgt 是伪指令，等价 blt zero,a5,.L2（有符号比较）。
- li a5, 1
  基例：n <= 0 时返回 1。把 1 放到 a5。
  注：li 是伪指令，通常是 addi a5,zero,1。
- j .L3
  跳到收尾（共同的返回路径）。
  注：j 是伪指令，等价 jal x0, .L3。

递归分支 .L2：计算 n * fact(n-1)
- .L2:
- lw a5, -20(s0)
  取回原始的 n。
- addiw a5, a5, -1
  a5 = (int32)(n - 1)。addiw 做 32 位加法并把结果按 32 位符号扩展到 64 位。
- sext.w a5, a5
  再次显式符号扩展到 64 位（多余但常见于 -O0 代码）。
- mv a0, a5
  把 n-1 放到 a0，作为调用参数。
- call fact
  调用 fact(n-1)。这是伪指令，展开为 auipc/jalr 组合或 jal。
  调用返回后，返回值在 a0。
- mv a5, a0
  把返回值 fact(n-1) 放到 a5。
- lw a4, -20(s0)
  再次从栈上取出原始 n 到 a4（因为调用破坏了 a 寄存器，编译器把 n 保存在栈上以便回用）。
- mulw a5, a4, a5
  a5 = (int32)(a4 * a5) = (int32)(n * fact(n-1))，结果按 32 位有符号扩展到 64 位。
  注：mulw 是 32 位乘法（RV64M 扩展）。
- sext.w a5, a5
  再做一次显式 32->64 位符号扩展（通常是冗余的）。

共同收尾 .L3（把结果放到返回寄存器并恢复栈帧）
- .L3:
- mv a0, a5
  把结果放到 a0（RISC‑V 约定用 a0 返回整数）。
- ld ra, 24(sp)
  恢复保存的 ra。
- ld s0, 16(sp)
  恢复保存的 s0（旧帧指针）。
- addi sp, sp, 32
  回收栈帧，sp 复位。
- jr ra
  返回到调用者。jr 是伪指令，等价 jalr x0, ra, 0。

补充说明
- 为什么要 32 字节栈帧？RV64 规定调用点 sp 必须 16 字节对齐。这里保存了两个 8 字节寄存器（ra, s0）并留出局部变量空间，分配 32 字节简化对齐。
- 寄存器使用与调用约定：
  - a0-a7（x10-x17）为参数/调用者保存寄存器；调用其他函数前，若需保留其值，调用者要自己保存。所以编译器把 n 存到了栈上，递归返回后再取。
  - s0（x8）是被调用者保存寄存器，用作帧指针，需要在进入时保存、退出时恢复。
  - ra（x1）保存返回地址；本函数内部有调用，因此需要把 ra 入栈。
- 32 位与 64 位：
  - C 里的 int 是 32 位，因此使用 sw/lw、addiw、mulw，并频繁用 sext.w 保证寄存器中的数在 64 位宽度下保持正确符号。
  - 在 RV64 上，lw 本身就是有符号扩展；addiw/mulw 的结果也会符号扩展到 64 位，所以有些 sext.w 是冗余的（常见于未优化编译）。
- 逻辑等价性：
  - 原 C 判断是 if (n < 1) return 1; else ...；汇编用的是“如果 n > 0 去递归，否则返回 1”，等价地覆盖了 n <= 0 的基例。

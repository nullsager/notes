### 大小写转换
将整行文本转换为大写：

命令模式下，输入 gU 加上行号或范围。例如：
1. gUU：将当前行转换为大写。
2. 5gU：将当前行到第5行的内容转换为大写。
3. VgU：选择当前行并转换为大写。

将整行文本转换为小写：

命令模式下，输入 gu 加上行号或范围。例如：
1. guu：将当前行转换为小写。
2. 5gu：将当前行到第5行的内容转换为小写。
3. Vgu：选择当前行并转换为小写。

---

### 单词替换
1. 将当前行的指定单词进行替换:`:s/旧单词/新单词/g`
2. 全文件替换:`:%s/旧单词/新单词/g`
3. 在特定范围内替换:`:范围s/旧单词/新单词/g`，例如，`:5,15s/foo/bar/g`

为了确保只替换完整的单词，可以使用 \b 表示单词边界：`:%s/\<旧单词\>/新单词/g`，例如：`:%s/\<foo\>/bar/g`，这样只替换独立的 foo，不影响 foobar

如果希望在每次替换前进行确认，可以在命令末尾添加 c: `:%s/旧单词/新单词/gc`

---

### 执行外部命令

`:!command`：这个命令可以执行一个外部的系统命令。

例如，用 !ls (在Unix系统) 或 !dir (在Windows系统) 可以显示当前目录的文件列表。用 `!rm FILENAME` 可以删除一个文件。

`:w FILENAME`：这个命令会将当前编辑器中的内容写入（保存）到名为 FILENAME 的文件中。

`v motion :w FILENAME`：这个命令用于将在可视化模式（Visual mode）下选中的行保存到 FILENAME 文件中。

`:r FILENAME`：这个命令会读取 FILENAME 文件的内容，并将其插入到当前光标位置的下方。

`:r !command`：这个命令会执行一个外部命令（如 ls 或 dir），并将其输出结果读取并插入到当前光标位置的下方。

---
### 常用 `c` 命令

| 命令            | 作用                               | 说明                                        |
| :------------ | :------------------------------- | :---------------------------------------- |
| `cw`          | **Change Word**                  | 删除从光标到当前单词结尾的字符，并进入插入模式。这是最常用的命令之一。       |
| `ciw`         | **Change Inner Word**            | 更改光标所在的整个单词（不包括单词后的空格）。                   |
| `caw`         | **Change A Word**                | 更改光标所在的整个单词（包括单词后的空格）。                    |
| `cc`          | **Change Line**                  | 删除当前整行，并进入插入模式。这是一个非常高效的整行修改快捷键。          |
| `C` (大写)      | **Change to End of Line**        | 删除从光标到行尾的所有内容，并进入插入模式。它等价于 `c$`。          |
| `c$`          | **Change to End of Line**        | 和 `C` 的作用完全一样。                            |
| `c^`          | **Change to Beginning of Line**  | 删除从光标到行首（第一个非空白字符）的内容，并进入插入模式。            |
| `c0`          | **Change to Absolute Beginning ` | 删除从光标到该行绝对行首的内容，并进入插入模式。                  |
| `ci(` 或 `ci)` | **Change Inner Parentheses**     | 更改当前括号 `()` 内的所有内容。                       |
| `ci"` 或 `ci'` | **Change Inner Quotes**          | 更改当前引号 `""` 或 `''` 内的所有内容。                |
| `ct{char}`    | **Change Till {char}**           | 更改从光标到下一个 `{char}` 字符之间的内容（不包括 `{char}`）。 |
结合数字使用

还可以在 `c` 命令前或 `motion` 前加上数字，表示重复执行。

* `c2w`: 更改从光标开始的两个单词。
* `2cw`: 和 `c2w` 作用相同。
* `c3l`: 更改光标后的 3 个字符。

---
### t/T 的使用
####  `t{char}` - "Till" (向前移动)

* **作用**：向前（向右）查找在本行出现的字符 `{char}`，并将光标移动到该字符的**前一个**位置。
* **记忆方法**：可以记为 "move **t**ill {char}"。
* **如果未找到**：光标不会移动。

**示例：**

假设你的光标 `|` 在一行的开头：
`|This is a simple line.`

1.  输入 `ts`：光标会移动到 `s` 的前面，即 `i` 的位置。
    `This i|s a simple line.`

2.  输入 `tl`：光标会移动到 `l` 的前面，即 `e` 的位置。
    `This is a simp|le line.`

**与 `c` 命令结合使用：**

* `ct.`：从光标位置更改（change）到下一个句号 `.` 之前的所有内容。这在修改一句话的前半部分时非常有用。
    * 执行前：`|This is a simple line.`
    * 执行 `ct.` 后：`.` (删除了 "This is a simple line"，并进入插入模式等待输入)

---

#### `T{char}` - "Till" (向后移动)

* **作用**：向后（向左）查找在本行出现的字符 `{char}`，并将光标移动到该字符的**后一个**位置。
* **记忆方法**：可以理解为 `t` 的反向操作。
* **如果未找到**：光标不会移动。

**示例：**

假设你的光标 `|` 在一行的末尾：
`This is a simple line.|`

1.  输入 `Ti`：光标会向后移动到 `i` 的后面，即 `m` 的位置。
    `This is a si|mple line.`

2.  输入 `Ts`：光標會向後移動到 `s` 的後面，即 ` ` (空格) 的位置。
    `This i|s a simple line.`

**与 `d` 命令结合使用：**

* `dTi`：从光标位置向后删除（delete）到 `i` 字符之后的所有内容。
    * 执行前：`This is a simple line.|`
    * 执行 `dTi` 后：`This i` (删除了 "s a simple line.")

---

#### `;` 和 `,` - 重复查找

在你使用 `t{char}` 或 `T{char}` 进行了一次查找之后：

* `;`：**重复**上一次的 `t` 或 `T` 命令，继续向同一个方向查找下一个匹配的字符。
* `,`：**反向重复**上一次的 `t` 或 `T` 命令。

**示例：**

假设你的光标 `|` 在一行的开头：
`|one two one three`

1.  输入 `to`：光标移动到第一个 `o` 的前面，即 ` ` (空格) 的位置。
    `one| two one three`
2.  输入 `;`：光标会继续向前查找下一个 `o`，并移动到它的前面。
    `one two |one three`
3.  输入 `,`：光标会反向查找上一个 `o`，并移动到它的后面。
    `on|e two one three`

#### 与 `f` / `F` 的区别

`t` / `T` 与 `f` / `F` 非常相似，但有一个关键区别：

* **`f{char}` / `F{char}` (Find)**：将光标直接移动到指定的字符 `{char}` 上。
* **`t{char}` / `T{char}` (Till)**：将光标移动到指定的字符 `{char}` 的**相邻位置**（前或后）。

这个区别使得 `t` / `T` 在与 `c`, `d`, `y` 等操作符命令结合时特别有用，因为你通常想要操作的是**两个字符之间**的内容，而不是包含结束字符本身。例如，要更改括号内的内容，`ci(` 更方便，但如果想从光标更改到某个逗号之前，`ct,` 就是完美的选择。

---
好的，在 Vim 中，`r` 和 `R` 都是用于替换（Replace）文本的命令，但它们的工作方式和适用场景有很大不同。

---

### r/R 的使用

`r` 命令用于替换光标下的**单个字符**，执行后会**立即返回**普通模式（Normal Mode）。

* **语法**: `r{char}`
    * `r`: replace 命令。
    * `{char}`: 你想要替换成的新字符。

* **工作流程**:
    1.  将光标移动到你想要修改的字符上。
    2.  按下 `r` 键。
    3.  再按下你想要替换成的新字符。
    4.  替换完成，Vim 保持在普通模式。

> [!example]
> * **示例**:
>     假设文本是 `Hello, woxld!`，你想把 `x` 修改为 `r`。
>     1.  移动光标到 `x` 上。
>     2.  按下 `r`。
>     3.  按下 `r`。
>     4.  文本会立即变为 `Hello, world!`，光标停留在 `r` 上，并且你仍然在普通模式。

 
> [!tip]
> Contents
**特殊用法**:`r<Enter>`: 将光标下的字符替换为换行符，即将一行拆分为两行。

`R` - 进入替换模式 (Enter Replace Mode)

`R` 命令会使 Vim 进入**替换模式（Replace Mode）**。在这个模式下，你输入的每个字符都会**覆盖**光标下的字符，光标会随之向后移动。这非常类似于其他编辑器中的“改写/覆盖模式”(Overwrite Mode)。

* **语法**: `R`

* **工作流程**:
    1.  将光标移动到你想要开始替换的位置。
    2.  按下 `R` 键，Vim 左下角会显示 `-- REPLACE --`。
    3.  开始输入新的文本，新文本会逐一覆盖原有文本。
    4.  输入完成后，按 `Esc` 键退出替换模式，返回普通模式。

> [!Example]
> * **示例**:
>     假设文本是 `The date is 2024-08-31.`，你想把 `2024` 修改为 `2025`。
>     1.  移动光标到 `2` 上。
>     2.  按下 `R` 进入替换模式。
>     3.  依次输入 `2025`。
>     4.  在输入过程中，文本会依次变为：
>         * `2` -> `2`
>         * `0` -> `0`
>         * `2` -> `2`
>         * `4` -> `5`
>     5.  最终文本变为 `The date is 2025-08-31.`。
>     6.  按下 `Esc` 返回普通模式。

* **注意**:
    * 如果在替换模式中输入超过了行尾，`R` 的行为会和插入模式一样，开始在行尾追加文本。


> [!summary]
> | 特性       | `r` (替换单个字符)                    | `R` (进入替换模式)                     |
> | :------- | :------------------------------ | :------------------------------- |
> | **作用**   | 替换光标下的**一个**字符。                 | **连续**替换光标及其后的字符。                |
> | **模式**   | **不会**改变模式，执行完立刻返回普通模式。         | **会**进入替换模式，需要按 `Esc` 退出。        |
> | **长度**   | 只能替换单个字符。                       | 可以替换任意长度的字符串。                    |
> | **记忆方法** | 小写的 **r**，影响小，只 **r**eplace 一个。 | 大写的 **R**，影响大，进入 **R**eplace 模式。 |
> 

---
好的，在 Vim 中，`m` 和 `M` 的用法**完全不同**，它们不像 `r` / `R` 或 `t` / `T` 那样是相关联的操作。这是一个常见的混淆点。

`m` 用于设置**标记 (Mark)**，而 `M` 是一个**移动 (Motion)** 命令。

---

### `m` - 设置标记 (Set a Mark)

`m` 命令的作用就像在书里加一个书签。你可以在文件的任意位置设置一个标记，方便之后快速跳转回来。

* **语法**: `m{char}`
    * `m`: mark 命令。
    * `{char}`: 标记的名称，可以是 `a-z` 或 `A-Z` 中的任意一个字母。

#### 标记的种类

1.  **小写字母标记 (`a-z`)**: **本地标记 (Local Mark)**
    * 作用范围仅限于**当前缓冲区（文件）**。
    * 你在 `file1.txt` 设置的 `ma`，在 `file2.txt` 中是无法访问的。
    * 每个文件都可以有自己的一套从 `a` 到 `z` 的标记。

2.  **大写字母标记 (`A-Z`)**: **全局标记 (Global Mark) / 文件标记 (File Mark)**
    * 作用范围是**全局的**，可以在不同的文件之间跳转。
    * 例如，在 `file1.txt` 中设置 `mA`，然后切换到 `file2.txt`，你依然可以从 `file2.txt` 直接跳回到 `file1.txt` 中 `A` 标记的位置。
    * 这在跨多个文件重构代码或参考文档时极为有用。

#### 如何使用标记 (跳转到标记)

设置好标记后，你需要用其他命令跳转到它。主要有两种方式：

* `` `{mark}` `` (反引号): **精确跳转**
    * 跳转到标记所在行的**确切光标位置**（行号和列号）。

* `'{mark}` (单引号): **行跳转**
    * 跳转到标记所在行的**行首**（第一个非空白字符）。

**示例:**

1.  **本地标记**:
    * 在一个长文件的第 50 行，光标在某个单词中间，按下 `ma` 来设置一个名为 `a` 的标记。
    * 你滚动到文件的其他地方进行编辑。
    * 想回来时，输入 `` `a ``，光标会精确地回到第 50 行你之前所在的那个单词中间。
    * 如果输入 `'a`，光标会回到第 50 行的行首。

2.  **全局标记**:
    * 在 `config.yml` 文件中，你正在查看一个重要的配置项，按下 `mC` (Mark C)。
    * 然后你打开 `main.py` 文件编写代码。
    * 在 `main.py` 中，你突然需要再次查看那个配置，直接输入 `` `C ``，Vim 会自动打开 `config.yml` 并将光标定位到你之前标记的确切位置。

#### 查看和删除标记

* `:marks`: 查看所有已设置的标记列表。
* `:delmarks a b C`: 删除名为 `a`, `b`, `C` 的标记。

---

### `M` - 移动到窗口中间行 (Move to Middle line)

`M` 是一个简单的移动命令，与标记完全无关。

* **作用**: 将光标移动到当前**可见窗口**的**中间行 (Middle)** 的第一个非空白字符上。

它有两个兄弟命令，通常一起记忆：

* `H`: **H**igh，移动到可见窗口的**最顶行**。
* `M`: **M**iddle，移动到可见窗口的**最中间行**。
* `L`: **L**ow，移动到可见窗口的**最底行**。

**示例:**

* 当你的屏幕显示了文件的第 100 行到第 150 行时：
    * 按 `H`，光标会移动到第 100 行的行首。
    * 按 `M`，光标会移动到大约第 125 行的行首。
    * 按 `L`，光标会移动到第 150 行的行首。

---
好的，与前面几组命令类似，`q` 和 `Q` 在 Vim 中也是功能完全不同的两个命令。`q` 用于**宏录制 (Macro Recording)**，而 `Q` 用于进入一种特殊的**Ex 模式 (Ex Mode)**。

-----

### `q` - 录制和停止宏 (Record Macro)

`q` 命令是 Vim 中最强大的功能之一，它允许你**录制一系列的操作**，然后像播放磁带一样重复执行它们。这对于执行重复性的编辑任务来说是无价之宝。

> [!info] 工作流程
> 
> 1.  **开始录制 (`q{register}`)**:
> 
>       * 在普通模式下，按下 `q`，然后再按一个**小写字母**（`a-z`）作为保存宏的"寄存器"名称。
>       * 例如，按下 `qa` 就会开始录制宏，并将其保存在寄存器 `a` 中。
>       * 此时，Vim 的左下角会出现 `recording @a` 的提示。
> 
> 2.  **执行操作**:
> 
>       * 从现在开始，你在 Vim 中执行的**所有键盘操作**（移动、插入、删除、命令等）都会被记录下来。
>       * **关键提示**: 在录制宏时，尽量使用相对移动（如 `j`, `w`, `^`, `$`）而非绝对移动（如 `50G`），这样宏才具有通用性。
> 
> 3.  **停止录制 (`q`)**:
> 
>       * 当你完成了所有想要录制的操作后，再次在普通模式下按下 `q` 即可停止录制。
>       * 左下角的 `recording @a` 提示会消失。
> 
> 4.  **播放宏 (`@{register}`)**:
> 
>       * 将光标移动到你想要执行宏的位置。
>       * 按下 `@`，然后跟上你之前选择的寄存器名称。
>       * 例如，按下 `@a` 就会执行保存在寄存器 `a` 中的所有操作。
> 
> 5.  **重复播放 (`@@`)**:
> 
>       * 在你使用 `@a` 执行过一次宏之后，Vim 会记住 `a` 是最后一个被执行的宏。
>       * 你可以简单地按下 `@@` 来重复执行上一次的宏，这比 `@a` 更快。

> [!Example]
> 给多行添加引号
> 
> 假设你有以下文本：
> 
> ```
> apple
> banana
> cherry
> ```
> 
> 你希望将它们变成：
> 
> ```
> "apple"
> "banana"
> "cherry"
> ```
> 
> **录制步骤 (`qa`)**：
> 
> 6.  将光标放在 `apple` 的 `a` 上。
> 7.  按下 `qa` 开始录制宏到寄存器 `a`。
> 8.  按下 `I`，进入行首插入模式，输入 `"`，再按 `Esc` 回到普通模式。 (行首添加了引号)
> 9.  按下 `A`，进入行尾插入模式，输入 `"`，再按 `Esc` 回到普通模式。 (行尾添加了引号)
> 10.  按下 `j`，将光标移动到下一行的行首，为下一次执行宏做准备。**（这是最关键的一步，保证宏可以连续执行）**
> 11.  按下 `q` 停止录制。
> 
> 现在，你的宏已经录制完成。光标应该在 `banana` 这一行。
> 
> **播放步骤**:
> 
> 12.  按下 `@a`，`banana` 这一行就会被修改，并且光标移动到 `cherry`。
> 13.  再按下 `@@`，`cherry` 这一行也会被修改。
> 
> 你也可以使用 `2@a` 来连续执行两次宏。

---
当然，我们来详细讲解 Vim 中的 `z` 和 `Z` 命令。这两个同样是功能完全不同的命令族。

`z` 是一个**前缀键 (prefix key)**，它引出了一系列与**屏幕滚动、代码折叠和拼写检查**相关的命令。可以把它理解为与**视图 (View)** 相关的操作。

`Z` 也是一个前缀键，但它只引出两个命令，都与**保存和退出文件**相关。

---

### `z` 命令族 (视图/屏幕管理)

当你按下 `z` 后，Vim 会等待你输入下一个字符来决定具体执行哪个操作。这些操作主要用于调整当前文本在屏幕上的显示方式，而**不改变文本内容**。

#### 1. 屏幕滚动命令 (Scrolling)

这是 `z` 命令最常用的功能，用于将当前行重新放置在屏幕的不同位置。

| 命令 | 作用 | 助记 |
| :--- | :--- | :--- |
| `zz` | **重绘屏幕，并将当前行置于屏幕正中央**。 | 两个 `z`，居中对齐。 |
| `zt` | **重绘屏幕，并将当前行置于屏幕顶部 (top)**。 | **t** for **t**op. |
| `zb` | **重绘屏幕，并将当前行置于屏幕底部 (bottom)**。 | **b** for **b**ottom. |
| `z.` | 将当前行置于屏幕中央，并将光标移动到该行的第一个非空白字符。 | `.` 通常代表当前位置。 |
| `z-` | 将当前行置于屏幕底部，并将光标移动到该行的第一个非空白字符。 | `-` 在键盘底部。 |

**使用场景**：当你的光标所在行在屏幕的底部或顶部，导致上下文看不全时，使用 `zz` 可以快速将当前行置于视野中心，非常方便。

#### 2. 代码折叠命令 (Folding)

代码折叠是 Vim 中隐藏代码块（如函数体、if 语句块）以查看代码整体结构的功能。`z` 系列命令是控制折叠的核心。

| 命令 | 作用 | 助记 |
| :--- | :--- | :--- |
| `zc` | **关闭 (Close)** 一个折叠。 | **c** for **c**lose. |
| `zC` | 递归地关闭所有嵌套的折叠。 | |
| `zo` | **打开 (Open)** 一个折叠。 | **o** for **o**pen. |
| `zO` | 递归地打开所有嵌套的折叠。 | |
| `za` | **切换 (Toggle)** 折叠的打开/关闭状态。 | `a` for "and back" (来回切换)。 |
| `zA` | 递归地切换所有嵌套折叠的状态。 | |
| `zr` | **减少 (Reduce)** 折叠层级，即打开一层折叠。 | **r** for **r**educe folding. |
| `zR` | 打开所有折叠。 | |
| `zm` | **增加 (More)** 折叠层级，即关闭一层折叠。 | **m** for **m**ore folding. |
| `zM` | 关闭所有折叠。 | |
| `zf` | 基于一个动作 (motion) **创建 (Fold)** 一个折叠。 | **f** for **f**old creation. |
| `zd` | **删除 (Delete)** 光标下的折叠。 | **d** for **d**elete fold. |

**使用场景**：在阅读大型代码文件时，可以使用 `zM` 关闭所有折叠来查看文件大纲，然后用 `zo` 逐层打开你感兴趣的部分。

#### 3. 其他 `z` 命令

* **拼写检查**:
    * `zg`: 将光标下的单词添加到拼写词典中 (good word)。
    * `zw`: 将光标下的单词标记为错误单词 (wrong word)。
* **水平滚动**:
    * `zh`: 向右滚动半屏。
    * `zl`: 向左滚动半屏。

---

### `Z` 命令族 (保存与退出)

`Z` 命令是 `:[action]` 命令的快捷键，非常高效。

| 命令   | 作用                        | 等效的冒号命令      |
| :--- | :------------------------ | :----------- |
| `ZZ` | **保存并退出**。如果文件未被修改，则直接退出。 | `:wq` 或 `:x` |
| `ZQ` | **不保存并强制退出**。             | `:q!`        |

**使用场景**：

* `ZZ` 是日常使用中最快速、最优雅的“保存并退出”方式。因为你不需要按 `:`、`w`、`q`、`Enter` 四个键，只需要按住 `Shift` 再按两次 `Z` 即可。
* `ZQ` 用于你想放弃所有修改并快速退出的场景。

---
### 查看最近文件列表

```
: browse oldfiles
" 或使用简写
: bro ol
```
### 杂项

+ 在最近使用的两个 buffer 之间来回切换：`ctrl+^`
+ 展开函数/折叠函数：`zo/zc`
+ 使用 `<C-o>` 向前跳，使用 `<C-i>` 向后跳
+  `<C-g>`：列出当前文件的信息以及现在所处的位置
+ **R (大写): 进入替换模式 (Replace mode)。在这个模式下，你输入的每个字符都会覆盖光标下的原有字符。这个模式会一直持续，直到你按下 `<Esc>` 键退出。**
+ `yiw`：复制当前光标所指词，`ciw`：修改当前光标所指词
+ S：删除一整行并进入编辑模式
+ `~`：切换光标下字符的大小写，并向右移动一个字符。
+ `*`  向前搜索光标下方的整个单词。无需手动输入，非常快捷。
+ `#`  向后搜索光标下方的整个单词。
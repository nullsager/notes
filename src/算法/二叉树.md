#算法/树

# 题目1

[二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/)

```cpp
class Solution {
public:
  vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    vector<TreeNode*> q(2001);
    if (root == nullptr) return {};
    vector<vector<int>> ans;
    int l = 0, r = 0;
    q[r++] = root;
    int flag = 0;
    while (l < r) {
      vector<int> tmp;
      if (flag) {
        for (int i = r - 1; i >= l; i--) {
          TreeNode* cur = q[i];
          tmp.push_back(cur->val);
        }
      } else {
        for (int i = l; i <= r - 1; i++) {
          TreeNode* cur = q[i];
          tmp.push_back(cur->val);
        }
      }
      int size = r - l;
      for (int i = 0; i < size; i++) {  // 这里size不可以写为r-l,r和l是变化的
        TreeNode* cur = q[l++];
        if (cur->left) q[r++] = cur->left;
        if (cur->right) q[r++] = cur->right;
      }
      ans.push_back(tmp);
      flag ^= 1;
    }
    return ans;
  }
};
```

---

# 题目2

[二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/description/)


> [!tip] tip
> 本题的关键是想到二叉树的节点的序号计算


```cpp
class Solution {
public:
  using ull = unsigned long long;
  int widthOfBinaryTree(TreeNode* root) {
    vector<TreeNode*> nq(3001);
    vector<ull> iq(3001);
    ull ans = 1;
    int l = 0, r = 0;
    nq[r] = root, iq[r++] = 1;
    while (l < r) {
      int size = r - l;
      ans = max(ans, iq[r - 1] - iq[l] + 1);
      for (int i = 0; i < size; i++) {
        TreeNode* node = nq[l];
        ull id = iq[l++];
        if (node->left) {
          nq[r] = node->left;
          iq[r++] = id * 2;
        }
        if (node->right) {
          nq[r] = node->right;
          iq[r++] = id * 2 + 1;
        }
      }
    }
    return ans;
  }
};
```

---

# 题目3

[二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

```cpp
class Solution {
public:
  int maxDepth(TreeNode* root) {
    return root == nullptr ? 0 : max(maxDepth(root->left), maxDepth(root->right)) + 1;
  }
};
```

[二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

```cpp
class Solution {
public:
  int minDepth(TreeNode* root) {
    if (root == nullptr) return 0;
    if (root->left == nullptr && root->right == nullptr) return 1;
    int min_depth = INT_MAX;
    if (root->left) min_depth = min(minDepth(root->left), min_depth);
    if (root->right) min_depth = min(minDepth(root->right), min_depth);
    return min_depth + 1;
  }
};
```

---

# 题目4

[二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/)


> [!tip] tip
> 本题主要是熟悉string,stringstream,getline之间的用法
> 可参考[getline与stringstream](getline与stringstream.md)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
  // Encodes a tree to a single string.
  string serialize(TreeNode* root) {
    stringstream builder;
    f(root, builder);
    return builder.str();
  }
  void f(TreeNode* root, stringstream& builder) {
    if (root == nullptr) {
      builder << "#,";
    } else {
      builder << root->val << ",";
      f(root->left, builder);
      f(root->right, builder);
    }
  }

  // Decodes your encoded data to tree.
  TreeNode* deserialize(string data) {
    stringstream ss(data);
    vector<string> vals;
    string item;
    while (getline(ss, item, ',')) {
      vals.push_back(item);
    }
    cnt = 0;
    return g(vals);
  }
  int cnt = 0;
  TreeNode* g(const vector<string>& vals) {
    if (cnt >= vals.size()) return nullptr;
    string cur = vals[cnt++];
    if (cur == "#") {
      return nullptr;
    } else {
      TreeNode* head = new TreeNode(stoi(cur));  // stoi将string转换为int
      head->left = g(vals);
      head->right = g(vals);
      return head;
    }
  }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
```
---

# 题目5

[从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

```cpp
class Solution {
public:
  unordered_map<int, int> mp;
  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    if (preorder.empty() || inorder.empty() || preorder.size() != inorder.size()) {
      return nullptr;
    }
    for (int i = 0; i < inorder.size(); i++) {
      mp[inorder[i]] = i;
    }
    return f(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
  }
  TreeNode* f(vector<int>& pre, int l1, int r1, vector<int>& in, int l2, int r2) {
    if (l1 > r1) return nullptr;
    TreeNode* head = new TreeNode(pre[l1]);
    if (l1 == r1) return head;
    int k = mp[pre[l1]];
    // in:(l2...)k(...r2)
    // 左边k-l2 右边r2-k
    head->left = f(pre, l1 + 1, l1 + k - l2, in, l2, k - 1);
    head->right = f(pre, l1 + k - l2 + 1, r1, in, k + 1, r2);
    return head;
  }
};
```

---

# 题目6

[二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/description/)

```cpp
class Solution {
public:
  bool isCompleteTree(TreeNode* root) {
    if (root == nullptr) return true;
    int l = 0, r = 0;
    vector<TreeNode*> q(101);
    q[r++] = root;
    bool leaf = false;  // 是否遇到过左右两个孩子不双全的节点
    while (l < r) {
      TreeNode* node = q[l++];
      if (node->left == nullptr && node->right) {  // 没有左子节点，有右子节点
        return false;
      }
      if (leaf && (node->left || node->right)) {  // 叶子节点之后，又出现非叶子节点
        return false;
      }
      if (node->left) q[r++] = node->left;
      if (node->right) q[r++] = node->right;
      if (node->left == nullptr || node->right == nullptr) {
        leaf = true;
      }
    }
    return true;
  }
};
```

---

# 题目7

[完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

```cpp
class Solution {
public:
  int h = 0;  // 整棵树的最大深度（从1开始计算）
  int countNodes(TreeNode* root) {
    if (!root) return 0;
    h = mostLeft(root, 1);
    return f(root, 1);
  }
  int mostLeft(TreeNode* cur, int dep) {
    while (cur) {
      dep++;
      cur = cur->left;
    }
    return dep - 1;
  }
  int f(TreeNode* cur, int dep) {
    if (dep == h) return 1;  // 到达叶节点
    if (mostLeft(cur->right, dep + 1) == h) {
      return (1 << (h - dep)) + f(cur->right, dep + 1);
    } else {
      return (1 << (h - dep - 1)) + f(cur->left, dep + 1);
    }
  }
};
```

---

# 题目8

